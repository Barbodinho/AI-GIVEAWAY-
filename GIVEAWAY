# -*- coding: utf-8 -*-
# Raffle Bot - pure stdlib (no extra installs)
# Works with Telegram Bot API via urllib (long-polling)

import json, os, random, time, urllib.request, urllib.parse

# --------- CONFIG ---------
BOT_TOKEN = "7752787134:AAFax4YVQ6jQ1mvBheHQwFtUwPd7x-lHnMU"   # Ù…Ø«Ù„Ø§: "1234567890:AA....."
ADMIN_IDS = {2036839035}                 # Ø¢ÛŒØ¯ÛŒ Ø¹Ø¯Ø¯ÛŒ Ø®ÙˆØ¯Øª/Ø§Ø¯Ù…ÛŒÙ†â€ŒÙ‡Ø§ (Ø§Ø² @userinfobot Ø¨Ú¯ÛŒØ±)
DRAW_TIME_TEXT = "ÙØ±Ø¯Ø§ Ø³Ø§Ø¹Øª 20:00"      # Ù…ØªÙ† Ø§Ø·Ù„Ø§Ø¹â€ŒØ±Ø³Ø§Ù†ÛŒ Ø²Ù…Ø§Ù† Ù‚Ø±Ø¹Ù‡â€ŒÚ©Ø´ÛŒ
# --------------------------

API = f"https://api.telegram.org/bot{BOT_TOKEN}"
DATA_DIR = os.path.dirname(os.path.abspath(__file__))
F_PARTICIPANTS = os.path.join(DATA_DIR, "participants.json")
F_WINNERS = os.path.join(DATA_DIR, "winners.json")
F_CHANNELS = os.path.join(DATA_DIR, "required_channels.json")
F_STATE = os.path.join(DATA_DIR, "state.json")  # Ø¨Ø±Ø§ÛŒ offset

def load_json(path, default):
    try:
        with open(path, "r", encoding="utf-8") as f:
            return json.load(f)
    except Exception:
        return default

def save_json(path, obj):
    tmp = path + ".tmp"
    with open(tmp, "w", encoding="utf-8") as f:
        json.dump(obj, f, ensure_ascii=False, indent=2)
    os.replace(tmp, path)

# Ø¯Ø§Ø¯Ù‡â€ŒÙ‡Ø§
participants = load_json(F_PARTICIPANTS, {})   # user_id -> {"first_name":..., "username":...}
winners      = load_json(F_WINNERS,   {})      # user_id -> "won_at" (string)
channels     = load_json(F_CHANNELS,  [])      # ["@ch1", "@ch2"]
state        = load_json(F_STATE, {"offset": 0})

def api_get(method, params=None):
    if params:
        url = API + "/" + method + "?" + urllib.parse.urlencode(params)
    else:
        url = API + "/" + method
    with urllib.request.urlopen(url) as r:
        return json.loads(r.read().decode("utf-8"))

def api_post(method, payload):
    data = json.dumps(payload).encode("utf-8")
    req = urllib.request.Request(
        API + "/" + method, data=data,
        headers={"Content-Type": "application/json"}
    )
    with urllib.request.urlopen(req) as r:
        return json.loads(r.read().decode("utf-8"))

def send_message(chat_id, text, reply_markup=None, parse_mode=None):
    payload = {"chat_id": chat_id, "text": text}
    if reply_markup: payload["reply_markup"] = reply_markup
    if parse_mode:   payload["parse_mode"] = parse_mode
    return api_post("sendMessage", payload)

def answer_callback_query(cb_id, text=None, show_alert=False):
    payload = {"callback_query_id": cb_id}
    if text is not None:
        payload["text"] = text
        payload["show_alert"] = bool(show_alert)
    return api_post("answerCallbackQuery", payload)

def get_member(chat_id, user_id):
    # chat_id Ù…ÛŒâ€ŒØªÙˆÙ†Ù‡ @channel Ø¨Ø§Ø´Ø¯
    try:
        return api_get("getChatMember", {"chat_id": chat_id, "user_id": user_id})
    except Exception:
        return {"ok": False}

def is_admin(uid): return uid in ADMIN_IDS

def channel_keyboard():
    # Ø¯Ú©Ù…Ù‡â€ŒÙ‡Ø§ÛŒ Ø´ÛŒØ´Ù‡â€ŒØ§ÛŒ: Ù„ÛŒÙ†Ú© Ú©Ø§Ù†Ø§Ù„â€ŒÙ‡Ø§ + Â«Ø¹Ø¶Ùˆ Ø´Ø¯Ù… âœ…Â»
    buttons = []
    for ch in channels:
        url = f"https://t.me/{ch.lstrip('@')}"
        buttons.append([{"text": ch, "url": url}])
    buttons.append([{"text": "Ø¹Ø¶Ùˆ Ø´Ø¯Ù… âœ…", "callback_data": "verify_join"}])
    return {"inline_keyboard": buttons}

def check_joined_all(uid):
    if not channels:
        return True
    for ch in channels:
        resp = get_member(ch, uid)
        if not resp.get("ok"):
            return False
        status = resp["result"]["status"]
        if status in ("left", "kicked"):
            return False
    return True

def add_participant(user):
    participants[str(user["id"])] = {
        "first_name": user.get("first_name",""),
        "username": user.get("username","")
    }
    save_json(F_PARTICIPANTS, participants)

def mark_winner(uid, when_str):
    winners[str(uid)] = when_str
    save_json(F_WINNERS, winners)

def list_candidates():
    # Ú©Ø³Ø§Ù†ÛŒ Ú©Ù‡ Ù‡Ù†ÙˆØ² Ø¨Ø±Ù†Ø¯Ù‡ Ù†Ø´Ø¯Ù‡â€ŒØ§Ù†Ø¯
    out = []
    for uid, info in participants.items():
        if uid not in winners:
            out.append((int(uid), info.get("first_name",""), info.get("username","")))
    return out

def cmd_start(chat_id):
    text = "Ø³Ù„Ø§Ù…! ğŸ‘‹\nÙ„Ø·ÙØ§Ù‹ Ø§Ø¨ØªØ¯Ø§ Ø¯Ø± Ú©Ø§Ù†Ø§Ù„â€ŒÙ‡Ø§ÛŒ Ø²ÛŒØ± Ø¹Ø¶Ùˆ Ø´ÙˆÛŒØ¯ Ùˆ Ø³Ù¾Ø³ Ø±ÙˆÛŒ Â«Ø¹Ø¶Ùˆ Ø´Ø¯Ù… âœ…Â» Ø¨Ø²Ù†ÛŒØ¯."
    if not channels:
        text += "\n(ÙØ¹Ù„Ø§Ù‹ Ú©Ø§Ù†Ø§Ù„ Ø§Ø¬Ø¨Ø§Ø±ÛŒ ØªÙ†Ø¸ÛŒÙ… Ù†Ø´Ø¯Ù‡ Ø§Ø³Øª.)"
    else:
        text += "\n\n" + "\n".join(f"â€¢ {c}" for c in channels)
    send_message(chat_id, text, reply_markup=channel_keyboard())

def cmd_setchannels(chat_id, uid, args):
    if not is_admin(uid):
        send_message(chat_id, "â›”ï¸ Ø§ÛŒÙ† Ø¯Ø³ØªÙˆØ± ÙÙ‚Ø· Ø¨Ø±Ø§ÛŒ Ø§Ø¯Ù…ÛŒÙ† Ø§Ø³Øª.")
        return
    if not args:
        send_message(chat_id, "Ù†Ø­ÙˆÙ‡ Ø§Ø³ØªÙØ§Ø¯Ù‡:\n/setchannels @ch1 @ch2 ...")
        return
    newchs = []
    for a in args:
        a = a.strip()
        if not a: continue
        if not a.startswith("@"): a = "@" + a
        newchs.append(a)
    global channels
    channels = newchs
    save_json(F_CHANNELS, channels)
    send_message(chat_id, "âœ… Ø°Ø®ÛŒØ±Ù‡ Ø´Ø¯:\n" + "\n".join(f"â€¢ {c}" for c in channels))

def cmd_channels(chat_id):
    if not channels:
        send_message(chat_id, "Ú©Ø§Ù†Ø§Ù„ Ø§Ø¬Ø¨Ø§Ø±ÛŒ ØªÙ†Ø¸ÛŒÙ… Ù†Ø´Ø¯Ù‡ Ø§Ø³Øª.")
    else:
        send_message(chat_id, "Ú©Ø§Ù†Ø§Ù„â€ŒÙ‡Ø§ÛŒ ÙØ¹Ù„ÛŒ:\n" + "\n".join(f"â€¢ {c}" for c in channels))

def cmd_participants(chat_id, uid):
    if not is_admin(uid):
        send_message(chat_id, "â›”ï¸ Ø§ÛŒÙ† Ø¯Ø³ØªÙˆØ± ÙÙ‚Ø· Ø¨Ø±Ø§ÛŒ Ø§Ø¯Ù…ÛŒÙ† Ø§Ø³Øª.")
        return
    if not participants:
        send_message(chat_id, "ÙØ¹Ù„Ø§Ù‹ Ø´Ø±Ú©Øªâ€ŒÚ©Ù†Ù†Ø¯Ù‡â€ŒØ§ÛŒ Ù†Ø¯Ø§Ø±ÛŒÙ….")
        return
    lines = []
    for i, (uid, info) in enumerate(participants.items(), 1):
        lines.append(f"{i}. {info.get('first_name','')} (@{info.get('username','')}) â€“ {uid}")
    send_message(chat_id, "\n".join(lines)[:4000])

def cmd_winners(chat_id, uid):
    if not is_admin(uid):
        send_message(chat_id, "â›”ï¸ Ø§ÛŒÙ† Ø¯Ø³ØªÙˆØ± ÙÙ‚Ø· Ø¨Ø±Ø§ÛŒ Ø§Ø¯Ù…ÛŒÙ† Ø§Ø³Øª.")
        return
    if not winners:
        send_message(chat_id, "ØªØ§ Ø§Ù„Ø§Ù† Ø¨Ø±Ù†Ø¯Ù‡â€ŒØ§ÛŒ Ø«Ø¨Øª Ù†Ø´Ø¯Ù‡ Ø§Ø³Øª.")
        return
    lines = []
    for i, (uid, when) in enumerate(sorted(winners.items(), key=lambda x: x[1], reverse=True), 1):
        info = participants.get(uid, {})
        lines.append(f"{i}. {info.get('first_name','')} (@{info.get('username','')}) â€“ {uid} | {when}")
    send_message(chat_id, "\n".join(lines)[:4000])

def cmd_reset(chat_id, uid, arg):
    if not is_admin(uid):
        send_message(chat_id, "â›”ï¸ Ø§ÛŒÙ† Ø¯Ø³ØªÙˆØ± ÙÙ‚Ø· Ø¨Ø±Ø§ÛŒ Ø§Ø¯Ù…ÛŒÙ† Ø§Ø³Øª.")
        return
    global participants, winners
    if arg == "winners":
        winners = {}
        save_json(F_WINNERS, winners)
        send_message(chat_id, "âœ… Ù„ÛŒØ³Øª Ø¨Ø±Ù†Ø¯Ù‡â€ŒÙ‡Ø§ Ø±ÛŒØ³Øª Ø´Ø¯.")
    elif arg == "all":
        winners = {}; participants = {}
        save_json(F_WINNERS, winners); save_json(F_PARTICIPANTS, participants)
        send_message(chat_id, "âœ… Ù‡Ù…Ù‡â€ŒÚ†ÛŒØ² Ø±ÛŒØ³Øª Ø´Ø¯.")
    else:
        send_message(chat_id, "Ù†Ø­ÙˆÙ‡: /reset winners  ÛŒØ§  /reset all")

def cmd_random(chat_id, uid, app_now_text):
    if not is_admin(uid):
        send_message(chat_id, "â›”ï¸ Ø§ÛŒÙ† Ø¯Ø³ØªÙˆØ± ÙÙ‚Ø· Ø¨Ø±Ø§ÛŒ Ø§Ø¯Ù…ÛŒÙ† Ø§Ø³Øª.")
        return
    cands = list_candidates()
    # ÙÛŒÙ„ØªØ± Ø¹Ø¶ÙˆÛŒØª Ù„Ø­Ø¸Ù‡â€ŒØ§ÛŒ
    eligible = []
    for u, fn, un in cands:
        if check_joined_all(u):
            eligible.append((u, fn, un))
    if not eligible:
        send_message(chat_id, "Ú©Ø³ÛŒ ÙˆØ§Ø¬Ø¯ Ø´Ø±Ø§ÛŒØ· Ù†ÛŒØ³Øª.")
        return
    u, fn, un = random.choice(eligible)
    mark_winner(u, app_now_text)
    mention = f"[{fn}](tg://user?id={u})" if fn else f"Ú©Ø§Ø±Ø¨Ø± {u}"
    at = f"@{un}" if un else ""
    send_message(chat_id, f"ğŸ‰ Ø¨Ø±Ù†Ø¯Ù‡ Ø§ÛŒÙ† Ø¯ÙˆØ±: {mention} {at}", parse_mode="Markdown")

def handle_message(msg):
    chat = msg["chat"]["id"]
    uid  = msg["from"]["id"]
    text = msg.get("text","").strip()
    if not text.startswith("/"):
        return

    parts = text.split()
    cmd = parts[0].lower()
    args = parts[1:]

    if cmd == "/start":
        cmd_start(chat)
    elif cmd == "/setchannels":
        cmd_setchannels(chat, uid, args)
    elif cmd == "/channels":
        cmd_channels(chat)
    elif cmd == "/participants":
        cmd_participants(chat, uid)
    elif cmd == "/winners":
        cmd_winners(chat, uid)
    elif cmd == "/reset":
        cmd_reset(chat, uid, args[0].lower() if args else "")
    elif cmd == "/random":
        now = time.strftime("%Y-%m-%d %H:%M:%S", time.localtime())
        cmd_random(chat, uid, now)
    else:
        send_message(chat, "Ø¯Ø³ØªÙˆØ± Ù†Ø§Ù…Ø´Ø®Øµ Ø§Ø³Øª.")

def handle_callback(cb):
    cb_id = cb["id"]
    uid   = cb["from"]["id"]
    msg   = cb["message"]
    chat  = msg["chat"]["id"]
    data  = cb.get("data","")

    if data == "verify_join":
        if check_joined_all(uid):
            # Ø«Ø¨Øª Ø´Ø±Ú©Øªâ€ŒÚ©Ù†Ù†Ø¯Ù‡
            add_participant(cb["from"])
            answer_callback_query(cb_id, "Ø«Ø¨Øª Ø´Ø¯ âœ…")
            send_message(chat, f"âœ… Ø´Ù…Ø§ Ø¯Ø± Ù‚Ø±Ø¹Ù‡â€ŒÚ©Ø´ÛŒ Ø´Ø±Ú©Øª Ø¯Ø§Ø¯Ù‡ Ø´Ø¯ÛŒØ¯!\nâ° Ø²Ù…Ø§Ù† Ù‚Ø±Ø¹Ù‡â€ŒÚ©Ø´ÛŒ: {DRAW_TIME_TEXT}\nÙ…ÙˆÙÙ‚ Ø¨Ø§Ø´ÛŒØ¯ ğŸ€")
        else:
            answer_callback_query(cb_id, "Ù‡Ù†ÙˆØ² Ø¹Ø¶Ùˆ Ù‡Ù…Ù‡Ù” Ú©Ø§Ù†Ø§Ù„â€ŒÙ‡Ø§ Ù†ÛŒØ³ØªÛŒØ¯.", show_alert=True)
            send_message(chat, "Ù‡Ù†ÙˆØ² Ù‡Ù…Ù‡Ù” Ú©Ø§Ù†Ø§Ù„â€ŒÙ‡Ø§ÛŒ Ù„Ø§Ø²Ù… Ø±Ø§ Ø¹Ø¶Ùˆ Ù†Ø´Ø¯Ù‡â€ŒØ§ÛŒØ¯. ğŸ™",
                         reply_markup=channel_keyboard())

def main():
    print("Raffle bot (stdlib) started.")
    while True:
        try:
            upd = api_get("getUpdates", {"timeout": 50, "offset": state["offset"] + 1})
            if not upd.get("ok"):
                time.sleep(2); continue
            for u in upd["result"]:
                state["offset"] = u["update_id"]
                save_json(F_STATE, state)

                if "message" in u:
                    handle_message(u["message"])
                elif "callback_query" in u:
                    handle_callback(u["callback_query"])
        except KeyboardInterrupt:
            print("Stopped by user"); break
        except Exception as e:
            # Ø±ÙˆÛŒ Ø®Ø·Ø§ Ú©Ù…ÛŒ ØµØ¨Ø± Ú©Ù† Ùˆ Ø¯ÙˆØ¨Ø§Ø±Ù‡ ØªÙ„Ø§Ø´ Ú©Ù†
            print("Error:", e)
            time.sleep(3)

if __name__ == "__main__":
    if not BOT_TOKEN or "PUT_YOUR_BOT_TOKEN_HERE" in BOT_TOKEN:
        raise SystemExit("BOT_TOKEN Ø±Ø§ Ø¯Ø± Ø¨Ø§Ù„Ø§ ÙˆØ§Ø±Ø¯ Ú©Ù†.")
    main()
